'use strict';

var _ = require('lodash');
var async = require('async');
var path = require('path');

var annotate = require('./annotate');
var ModuleContext = require('./moduleContext');

var mc = null;

function computeArgs(optName, replace, module, callback) {
  var deps = annotate(module);

  deps = _.map(deps, function (dep) {
    if (dep in replace) {
      dep = replace[dep];
    }

    if (dep[0] === '$') {
      dep = path.join(
        path.dirname(optName),
        dep.substr(1)
      );
    }

    return dep;
  });

  async.map(deps, mc.getModule.bind(mc), callback);
}

function inject(optName, replace, module, callback) {
  if (arguments.length < 3) {
    callback = module;
    module = undefined;
  }
  if (module === undefined) {
    module = replace;
    replace = {};
  }

  if (!_.isObject(replace) || _.isFunction(replace)) {
    throw new Error('[r42] Replace argument should be an object mapping argument names to modules.');
  }

  if (!_.isFunction(module)) {
    throw new Error('[r42] Module argument should be a valid function.');
  }

  callback = callback || function(err, res) { if (err) { throw err; } };

  computeArgs(optName, replace, module, function (err, args) {
    if (err) {
      return callback(err);
    }

    callback(null, module.apply(global, args));
  });
}

function define(name, replace, module, callback) {
  if (arguments.length < 4) {
    callback = module;
    module = undefined;
  }
  if (module === undefined) {
    module = replace;
    replace = {};
  }

  mc.addModule(name, _.partial(inject, name, replace, module), callback);
}

module.exports = {
  inject: _.createCallback(_.partial(inject, null), null, 2),
  config: function (config) {
    mc = new ModuleContext(config, define);
  },
};
