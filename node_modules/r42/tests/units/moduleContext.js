'use strict';

require('../helpers/dotry');

var path = require('path');
var chai = require('chai');
var expect = chai.expect;
var sinon = require('sinon');
var sinonChai = require('sinon-chai');
chai.use(sinonChai);

var ModuleContext = require('../../lib/moduleContext');

describe('ModuleContext', function () {
  it('is a function', function () {
    expect(ModuleContext).to.be.an('Function');
  });

  it('throws an error if called without arguments', function () {
    var fn = function () {
      ModuleContext();
    }
    expect(fn).to.throw(Error, '[r42] ModuleContext: invalid config object');
  });

  it('throws an error if first argument is invalid', function () {
    var fn = function () {
      ModuleContext(42);
    }
    expect(fn).to.throw(Error, '[r42] ModuleContext: invalid config object');
  });

  it('throws an error if second argument is invalid', function () {
    var fn = function () {
      ModuleContext({
        baseDir: 'test',
      }, 42);
    }
    expect(fn).to.throw(Error, '[r42] ModuleContext: invalid define function');
  });

  it('instantiate a new ModuleContext when called with new', function () {
    var res = null;
    var fn = function () {
      res = new ModuleContext({
        baseDir: 'test',
      }, function () {});
    }
    expect(fn).not.to.throw();
    expect(res).to.be.an.instanceOf(ModuleContext);
  });

  it('instantiate a new ModuleContext when called without new', function () {
    var res = null;
    var fn = function () {
      res = ModuleContext({
        baseDir: 'test',
      }, function () {});
    }
    expect(fn).not.to.throw();
    expect(res).to.be.an.instanceOf(ModuleContext);
  });

  it('sets $modules to a new empty object when instantiating', function () {
    var res = ModuleContext({
      baseDir: 'test',
    }, function () {});

    expect(res.$modules).to.be.deep.eql({});
  });

  it('sets $baseDir to config.baseDir when instantiating', function () {
    var res = ModuleContext({
      baseDir: 'test',
    }, function () {});

    expect(res.$baseDir).to.be.eql('test');
  });

  it('sets $mm to a new ModuleMapper when instantiating', function () {
    var res = ModuleContext({
      baseDir: 'test',
    }, function () {});

    expect(res.$mm).to.be.an.instanceOf(require('../../lib/moduleMapper'));
  });

  it('sets $define to define argument when instantiating', function () {
    var define = function () {};
    var res = ModuleContext({
      baseDir: 'test',
    }, define);

    expect(res.$define).to.be.eql(define);
  });

  describe('#addModule', function () {
    var mc = null;
    beforeEach(function () {
      mc = ModuleContext({
        baseDir: 'test',
      }, function () {});
    });

    it('is a function', function () {
      expect(mc.addModule).to.be.a('Function');
    });

    it('throws an error if addModule is called with an already existing module', function () {
      mc.$modules.test = {};
      var fn = function () {
        mc.addModule('test', function () {}, function () {});
      };
      expect(fn).to.throw(
        Error,
        '[r42] ModuleContext: impossible to redefine already existing module test'
      );
    });

    it('initialize $modules[<moduleName>] to null during instantiation', function () {
      var called = 0;
      mc.addModule('test', function () {
        ++called;
        expect(mc.$modules.test).to.be.null;
      }, function () {});
      expect(called).to.be.eql(1);
    });

    it('calls the provided moduleFn function with callback', function () {
      var called = 0;
      mc.addModule('test', function (cb) {
        ++called;
        expect(cb).to.be.a('Function');
      }, function () {});
      expect(called).to.be.eql(1);
    });

    it('calls the provided callback directly with the error if ' +
      'moduleFn\'s returns one', function() {
      var called = 0;
      var sendErr = new Error('test');
      mc.addModule('test', function (cb) {
        cb(sendErr);
      }, function (err) {
        ++called;
        expect(err).to.be.eql(sendErr);
      });
      expect(called).to.be.eql(1);
    });

    it('calls the provided callback with the module\'s value if ' +
      'moduleFn\'s does not return an error', function() {
      var called = 0;
      var moduleValue = {};
      mc.addModule('test', function (cb) {
        cb(null, moduleValue);
      }, function (err, res) {
        ++called;
        expect(err).not.to.exist;
        expect(res).to.be.eql(moduleValue);
      });
      expect(called).to.be.eql(1);
    });

    it('save the module\'s value into $modules before calling the ' +
      'provided callback', function() {
      var called = 0;
      var moduleValue = {};
      mc.addModule('test', function (cb) {
        cb(null, moduleValue);
      }, function (err) {
        ++called;
        expect(err).not.to.exist;
        expect(mc.$modules.test).to.be.eql(moduleValue);
      });
      expect(called).to.be.eql(1);
    });
  });

  describe('#getModule', function () {
    var mc = ModuleContext({
      baseDir: 'test',
    }, function () {});

    it('is a function', function () {
      expect(mc.getModule).to.be.a('Function');
    });

    // TODO: a lot of missing tests here
  });

  describe('#removeModule', function () {
    var mc = ModuleContext({
      baseDir: 'test',
    }, function () {});

    it('is a function', function () {
      expect(mc.removeModule).to.be.a('Function');
    });

    it('removes the module from $modules if it is in it', function () {
      mc.$modules.test = {};
      mc.removeModule('test');
      expect(mc.$modules).to.be.deep.eql({});
    });

    it('does nothing if the module does not exists in $modules', function () {
      mc.$modules.test = {};
      mc.removeModule('test2');
      expect(mc.$modules).to.be.deep.eql({
        test: {},
      });
    });
  });
});
